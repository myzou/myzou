<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试必考的HashMap]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F21%2F%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83%E7%9A%84HashMap%2F</url>
    <content type="text"><![CDATA[本文公众号来源：孤独烟 作者：孤独烟 转载请说明出处 正文 (1)HashMap的实现原理?此题可以组成如下连环炮来问 你看过HashMap源码嘛，知道原理嘛? 为什么用数组+链表？ hash冲突你还知道哪些解决办法？ 我用LinkedList代替数组结构可以么? 既然是可以的,为什么HashMap不用LinkedList,而选用数组? 你看过HashMap源码嘛，知道原理嘛?针对这个问题，嗯，当然是必须看过HashMap源码。至于原理，下面那张图很清楚了: HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。 只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树！ 为什么用数组+链表？ 数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到. 链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。 ps:这里的hash值并不是指hashcode，而是将hashcode高低十六位异或过的。至于为什么要这么做，继续往下看。 hash冲突你还知道哪些解决办法？比较出名的有四种(1)开放定址法(2)链地址法(3)再哈希法(4)公共溢出区域法 ps:大家有兴趣拓展的，自己去搜一下就懂了，这个就不拓展了！我用LinkedList代替数组结构可以么?这里我稍微说明一下，此题的意思是，源码中是这样的 1Entry[] table = new Entry[capacity]; ps：Entry就是一个链表节点。那我用下面这样表示 1List&lt;Entry&gt; table = new LinkedList&lt;Entry&gt;(); 是否可行?答案很明显，必须是可以的。既然是可以的,为什么HashMap不用LinkedList,而选用数组?因为用数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。 那ArrayList，底层也是数组，查找也快啊，为啥不用ArrayList?(烟哥写到这里的时候，不禁觉得自己真有想法，自己把自己问死了，还好我灵机一动想出了答案)因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。而ArrayList的扩容机制是1.5倍扩容，那ArrayList为什么是1.5倍扩容这就不在本文说明了。 (2)HashMap在什么条件下扩容?此题可以组成如下连环炮来问 HashMap在什么条件下扩容? 为什么扩容是2的n次幂? 为什么为什么要先高16位异或低16位再取模运算? HashMap在什么条件下扩容?如果bucket满了(超过load factor*current capacity)，就要resize。load factor为0.75，为了最大程度避免哈希冲突current capacity为当前数组大小。 为什么扩容是2的次幂?HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；这个算法实际就是取模，hash%length。但是，大家都知道这种运算不如位移运算快。因此，源码中做了优化hash&amp;(length-1)。也就是说hash%length==hash&amp;(length-1)那为什么是2的n次方呢？因为2的n次方实际就是1后面n个0，2的n次方-1，实际就是n个1。例如长度为8时候，3&amp;(8-1)=3 2&amp;(8-1)=2 ，不同位置上，不碰撞。而长度为5的时候，3&amp;(5-1)=0 2&amp;(5-1)=0，都在0上，出现碰撞了。所以，保证容积是2的n次方，是为了保证在做(length-1)的时候，每一位都能&amp;1 ，也就是和1111……1111111进行与运算。 为什么为什么要先高16位异或低16位再取模运算?我先晒一下，jdk1.8里的hash方法。1.7的比较复杂，咱就不看了。 hashmap这么做，只是为了降低hash冲突的几率。 打个比方，当我们的length为16的时候，哈希码(字符串“abcabcabcabcabc”的key对应的哈希码)对(16-1)与操作，对于多个key生成的hashCode，只要哈希码的后4位为0，不论不论高位怎么变化，最终的结果均为0。如下图所示 (3)讲讲hashmap的get/put的过程?此题可以组成如下连环炮来问 知道hashmap中put元素的过程是什么样么? 知道hashmap中get元素的过程是什么样么？ 你还知道哪些hash算法？ 说说String中hashcode的实现?(此题很多大厂问过) 知道hashmap中put元素的过程是什么样么?对key的hashCode()做hash运算，计算index;如果没碰撞直接放到bucket里；如果碰撞了，以链表的形式存在buckets后；如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树(JDK1.8中的改动)；如果节点已经存在就替换old value(保证key的唯一性)如果bucket满了(超过load factor*current capacity)，就要resize。 知道hashmap中get元素的过程是什么样么?对key的hashCode()做hash运算，计算index;如果在bucket里的第一个节点里直接命中，则直接返回；如果有冲突，则通过key.equals(k)去查找对应的Entry; 若为树，则在树中通过key.equals(k)查找，O(logn)； 若为链表，则在链表中通过key.equals(k)查找，O(n)。 你还知道哪些hash算法？先说一下hash算法干嘛的，Hash函数是指把一个大范围映射到一个小范围。把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。比较出名的有MurmurHash、MD4、MD5等等 说说String中hashcode的实现?(此题频率很高) 123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; String类中的hashCode计算方法还是比较简单的，就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。 哈希计算公式可以计为s[0]31^(n-1) + s[1]31^(n-2) + … + s[n-1]那为什么以31为质数呢?主要是因为31是一个奇质数，所以31*i=32*i-i=(i&lt;&lt;5)-i，这种位移与减法结合的计算相比一般的运算快很多。 (4)为什么hashmap的在链表元素数量超过8时改为红黑树?此题可以组成如下连环炮来问 知道jdk1.8中hashmap改了啥么? 为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树? 我不用红黑树，用二叉查找树可以么? 那为什么阀值是8呢? 当链表转为红黑树后，什么时候退化为链表? 知道jdk1.8中hashmap改了啥么? ** 由数组+链表的结构改为数组+链表+红黑树。 优化了高位运算的hash算法：h^(h&gt;&gt;&gt;16) 扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。 最后一条是重点，因为最后一条的变动，hashmap在1.8中，不会在出现死循环问题。 为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于8个当时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于8个的时候，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。 因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。 我不用红黑树，用二叉查找树可以么?可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。 那为什么阀值是8呢?不知道，等jdk作者来回答。这道题，网上能找到的答案都是扯淡。我随便贴一个牛客网的答案，如下图所示 看出bug没？交点是6.64？交点分明是4，好么。 log4=2，4/2=2。 jdk作者选择8，一定经过了严格的运算，觉得在长度为8的时候，与其保证链表结构的查找开销，不如转换为红黑树，改为维持其平衡开销。 当链表转为红黑树后，什么时候退化为链表?为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。 (5)HashMap的并发问题?此题可以组成如下连环炮来问 HashMap在并发编程环境下有什么问题啊? 在jdk1.8中还有这些问题么? 你一般怎么解决这些问题的？ HashMap在并发编程环境下有什么问题啊? (1)多线程扩容，引起的死循环问题 (2)多线程put的时候可能导致元素丢失 (3)put非null元素后get出来的却是null 在jdk1.8中还有这些问题么?在jdk1.8中，死循环问题已经解决。其他两个问题还是存在。 你一般怎么解决这些问题的？比如ConcurrentHashmap，Hashtable等线程安全等集合类。 (6)你一般用什么作为HashMap的key?此题可以组成如下连环炮来问 健可以为Null值么? 你一般用什么作为HashMap的key? 我用可变类当HashMap的key有什么问题? 如果让你实现一个自定义的class作为HashMap的key该如何实现？ 健可以为Null值么?必须可以，key为null的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置。 你一般用什么作为HashMap的key? 一般用Integer、String这种不可变类当HashMap当key，而且String最为常用。 (1)因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。 (2)因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的覆写了hashCode()以及equals()方法。 我用可变类当HashMap的key有什么问题?hashcode可能发生改变，导致put进去的值，无法get出，如下所示 12345678HashMap&lt;List&lt;String&gt;, Object&gt; changeMap = new HashMap&lt;&gt;();List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(&quot;hello&quot;);Object objectValue = new Object();changeMap.put(list, objectValue);System.out.println(changeMap.get(list));list.add(&quot;hello world&quot;);//hashcode发生了改变System.out.println(changeMap.get(list)); 输出值如下 12java.lang.Object@74a14482null 如果让你实现一个自定义的class作为HashMap的key该如何实现？此题考察两个知识点 重写hashcode和equals方法注意什么? 如何设计一个不变类 针对问题一，记住下面四个原则即可(1)两个对象相等，hashcode一定相等(2)两个对象不等，hashcode不一定不等(3)hashcode相等，两个对象不一定相等(4)hashcode不等，两个对象一定不等针对问题二，记住如何写一个不可变类(1)类添加final修饰符，保证类不被继承。如果类可以被继承会破坏类的不可变性机制，只要继承类覆盖父类的方法并且继承类可以改变成员变量值，那么一旦子类以父类的形式出现时，不能保证当前类是否可变。 (2)保证所有成员变量必须私有，并且加上final修饰通过这种方式保证成员变量不可改变。但只做到这一步还不够，因为如果是对象成员变量有可能再外部改变其值。所以第4点弥补这个不足。 (3)不提供改变成员变量的方法，包括setter避免通过其他接口改变成员变量的值，破坏不可变特性。 (4)通过构造器初始化所有成员，进行深拷贝(deep copy)如果构造器传入的对象直接赋值给成员变量，还是可以通过对传入对象的修改进而导致改变内部变量的值。例如： 123456public final class ImmutableDemo &#123; private final int[] myArray; public ImmutableDemo(int[] array) &#123; this.myArray = array; // wrong &#125; &#125; 这种方式不能保证不可变性，myArray和array指向同一块内存地址，用户可以在ImmutableDemo之外通过修改array对象的值来改变myArray内部的值。为了保证内部的值不被修改，可以采用深度copy来创建一个新内存保存传入的值。正确做法： 123456public final class MyImmutableDemo &#123; private final int[] myArray; public MyImmutableDemo(int[] array) &#123; this.myArray = array.clone(); &#125; &#125; (5)在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝这种做法也是防止对象外泄，防止通过getter获得内部可变成员对象后对成员变量直接操作，导致成员变量发生改变。]]></content>
      <tags>
        <tag>java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小电影]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F17%2F%E5%B0%8F%E7%94%B5%E5%BD%B1%2F</url>
    <content type="text"><![CDATA[1 200GANA-17182 300MIUM-4233 300MIUM-3694 259LUXU-11005 300MAAN-3706 300MAAN-387 GANA-894和服ABP-572cosABP-657浴衣ABS-040浴衣AKB-058cosplay(獸娘動物園)AP-300護士APNH-014學生制服AVOP-069劇情AVOP-109巫女AVOP-204巫女BF-261和服BF-324制服Caribbean010414-516巫女DIY-093巫女DVDES-664劇情DVDES-844和服EKDV-332cosplay巫女EKDV-411巫女EKDV-489女僕ELO-310黑絲襪ftvgirls.17.10.29.melody.teasing.a.butt.plugcosplayGS-067便装GVG-081和服HEY-019セクシ居酒屋物HNDS-046劇情HUNT-004巫女HUNT-856婚纱IBW-248便装IENE-808浴衣IPX-067便装IPX-081游女IPZ-599巫女IPZ-713禮服IPZ-921cosplayJUX-595和服LOVE-344和服MBD-678浴衣MDB-736和服MDB-783護士MGT-014便装MIAD-810女僕MIAD-908女僕MIAE-135女僕MIAE-149女僕MIAE-165劇情MIAE-166女僕MIAE-188護士MIDE-040女僕MIDE-308巫女MIDE-395劇情MIRD-128護士MKMP-164女僕MKMP-184浴衣MKMP-212浴衣MKSB-003浴衣MMTA-007cosplay(2B)MRSS-048便装MXGS-582護士MXGS-602護士MXGS-623便装NPV006换装nurses-from-hell護士ONCE-007和服ONGP-109女僕PGD-668金髮PGD-896兔女郎PPPD-431换裝PPPD-445女僕PXH-002護士RCT-502玩偶RCT-618旗袍RCT-803便装RCT-814-A巫女.VOBRCT-814-B巫女.VOBRCT-887婚纱RCT-966劇情RTP-105cosplaySABA-378巫女SAMA-657便装SCOP-171女僕SCOP-348女僕SCOP-386護士SCOP-470便装SCPX-197便装SCPX-236劇情SCR-099浴衣SDDE-311護士SDDE-318劇情SDDE-319和服SDDE-348和服SDDE-450劇情SDDE-489護士SDDE-495和服SDDE-495浴衣SDDE-498便装SDDE-505護士SDDE-521A護士SDDE-521B護士SDDE-522便装SDEN-021護士SDMT-773cosplaySDMU-734未亡人SDNM-069浴衣SERO-245R未亡人SNIS-656cosplaySNIS-724便装SPS-020換装女僕巫女SQTE-108巫女SSNI-036學生制服SSNI-043浴衣SSNI-081便装SSNI-115學生制服STAR-516巫女STAR-550便装STAR-768學生制服STAR-793和服STAR-846護士STAR-863便装SUPA-268便装SVDVD-411劇情T28-232巫女T28-252巫女T28-344巫女T28-526巫女TEK-089便装TPRO-003cosplayTPRO-007cosplayTRUM-002婚纱TURA-259劇情TWD-234-04巫女TWO-018學生制服VAGU-185劇情WANZ-123護士WANZ-124女僕WANZ-178護士WANZ-457劇情WANZ-485便装WANZ-523換装WANZ-535便装WANZ-599護士WANZ-653巫女WFS-007護士WNZ-402女僕WNZ-458女僕XRW-320巫女XV-843巫女XVSR-060修女ZIZG-013cosplayZUKO-042便装 1.透明人 番號參考:ALX-296、ALX-358、ALX-474、ALX-500VSPDS-099、VSPDS-131、VSPDS-192、VSPDS-203、VSPDS-239、VSPDS-257、VSPDS-274VSPDS-367、VSPDS-416、VSPDS-476、VSPDS-608、VSPDS-638SPRD-382、SPRD-536、MUM-148、TURA-185、MIAD-894 VSPDS-131: 這部蠻知名的，透明人在喪禮惡搞，甚至跟死者SEX，然後死者復活XD SDMT-444: 女學生會長(長澤梓)變成透明人 2.時間停止 (因為男性的很多，女性比較少見，故推薦女性為主角的) SDMS-955: 女學生使用時間停止器 MIGD-736: 同上 3.究極の妄想発明シリーズ 系列 任意門: RCT-005 透視眼鏡: RCT-010、RCT-039、RCT-084 如果電話亭: RCT-015 能男女交換身體的相機、手銬: RCT-024 能操縱女生身體的人偶: RCT-064、RCT-116 栽培: RCT-148請繼續往下閱讀… 4.從書中、電視中變出真人 (貞子？) 書: RCT-045 電視: SPS-005 5.玩偶、面罩、充氣娃娃、擬人化 熊麻吉真人版: RCT-502 二次元面罩: MIAD-399、MIAD-421 動物面罩: DOKS-248 (其實蠻可怕的…) 充氣娃娃: SDMT-361 麗しのマネキン夫人:VAGU-029、VAGU-032、VAGU-044、VAGU-060、VAGU-078 自慰套擬人化: MIAD-773 貓的報恩:SOE-319 狗的報恩:SNIS-706 6.FUCK1(F1)賽車 SDMS-993 7.宗教相關 千手觀音: RKI-058 天使: SDMS-644 8.玩命(？) 空中潮吹: SDMT-160 爆破: NHDT-673 獅子旁、吊橋做愛: SDMS-192 火箭筒: REAL-423 9.變大變小的特殊片 男生變小 STAR-044、OPEN-758 其實應該是改編小南的迷你情人(自行Google查詢) 女巨人 SDMS-439 小穴變成鑰匙孔 SACE-086 10.大逃(插)、全員逃走中題材 SVDVD-059、SVDVD-074、SVDVD-90、SVDVD-187ATOM-010、ATOM-040、ATOM-103、AVOP-117 11.綜藝、達成條件獲得100萬元 矛盾大對決 ATOM-082 不讓錢從口中掉落: SERO-004、SERO-010、SERO-014、SERO-018、SERO-031、SERO-036 在男友面前不能有感覺，獲得100萬 SDMU-189 賭博默示錄限定猜拳AV版 ATOM-214 12.奇蹟的插入 廊下でぶつかった瞬間、僕のチ○ポが彼女のマ○コに入っていた ………………………………………… 分隔線 神的語言]]></content>
      <tags>
        <tag>小电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的IDEA好用到飞起来]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F15%2F%E4%BD%A0%E7%9A%84IDEA%E5%A5%BD%E7%94%A8%E5%88%B0%E9%A3%9E%E8%B5%B7%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[版权声明：本文为CSDN博主「琦彦」的原创，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/fly910905/article/details/77868300 1.设置maven1234在File-&gt;settings-&gt;搜索mavenMavan home directory--设置maven安装包的bin文件夹所在的位置User settings file--设置setting文件所在的位置Local repository--设置本地仓库的 2.IDEA 设置代码行宽度12345678在File-&gt;settings-&gt;Editor-&gt;Code Style有人会问，如果输入的代码超出宽度界线时，如何让IDE自动将代码换行？有两种方式！第一种，在上述的“Right margin (columns)”的下方，有“Wrap when typing reaches right margin”选项，选中它，是什么效果呢？随着输入的字符的增加，当代码宽度到达界线时，IDEA会自动将代码换行。第一种方式是在输入代码时触发，还有第二种方式，在File-&gt;settings-&gt;Code Style-&gt;Java中，选中“Wrapping and Braces”选项卡，在“Keep when reformatting”中有一个“Ensure rigth margin is not exceeded”，选中它，是什么效果呢？从配置项的字面意思很容易理解，在格式化Java代码时，确保代码没有超过宽度界线。即输入的代码超出界线后， 3.IDEA 提示不区分大小写123首先打开File-----&gt;setting然后，输入：sensitive将右侧的 case sensitive completion 修改为NONE 4.IntelliJ强制更新Maven Dependencies1234567Intellj 自动载入Mave依赖的功能很好用，但有时候会碰到问题，导致pom文件修改却没有触发自动重新载入的动作，此时需要手动强制更新依赖。如下：手动删除Project Settings里面的Libraries内容；在Maven Project的试图里clean一下，删除之前编译过的文件；项目右键-》Maven-》ReimportOk， 此时发现依赖已经建立！ 5.idea的环境配置默认保存位置123idea的环境配置默认保存位置:C:\Users\xxxxxxxxx\.IntelliJIdea14 ,xxxxxx代表用户目录,可以对该目录进行备份,一但环境出问题恢复此配置即可.可以在%IDEA_HOME%/bin/idea.properties中修改该配置路径. 6.隐藏不想看到的文件或者文件夹（类似eclipse的filter功能）12intellij idea 隐藏不想看到的文件或者文件夹（类似eclipse的filter功能）打开intellij --&gt;:&gt;File --&gt;&gt;Settings--&gt;&gt;搜索File Types 7.修改为Eclipse快捷键1File -&gt; Settings -&gt; Keymap =&gt; Keymaps改为 Eclipse copy 8.修改默认设置–default setting1修改默认设置--default setting 9.修改智能提示快捷键12345File -&gt; Settings -&gt; Keymap -&gt; Main menu -&gt; Code -&gt; Completion -&gt; Basic=&gt;修改为Ctrl+Alt+Enter 保存时把冲突的Remove掉。File -&gt; Settings -&gt; Keymap -&gt; Editor Actions -&gt; Complete Current Statement=&gt;修改为Ctrl+; 10.查找快捷键冲突问题处理1File -&gt; Settings -&gt; Keymap -&gt; Main menu -&gt; Edit -&gt;Find =&gt;修改Find...和Replace...分别改为Ctrl+F 和Ctrl+R 11.显示行号1File -&gt; Settings -&gt;Editor -&gt;General -&gt; Appearance =&gt;Show line numbers选中 12.代码智能提示，忽略大小写1File -&gt; Settings -&gt; Editor -&gt; Code Completion里把Case sensitive completion设置为None就可以了 13.用*标识编辑过的文件123Editor–&gt;General –&gt; Editor Tabs在IDEA中，你需要做以下设置, 这样被修改的文件会以*号标识出来，你可以及时保存相关的文件。“Mark modifyied tabs with asterisk” 14.关闭自动代码提示1Preferences =&gt; IDE Settings =&gt; Editor =&gt; Code Completion =&gt; Autopopup documentation in (ms) 15.常用快捷键12345678910111213141516171819202122232425262728Ø Top #10切来切去：Ctrl+TabØ Top #9选你所想【选中上下文相关联代码】：Ctrl+WØ Top #8代码生成：Template/Postfix +TabØ Top #7发号施令：Ctrl+Shift+AØ Top #6无处藏身：Shift+ShiftØ Top #5自动完成：Ctrl+Shift+EnterØ Top #4创造万物：Alt+Insert使用前三名！ Ø Top #1智能补全：Ctrl+Shift+SpaceØ Top #1自我修复：Alt+EnterØ Top #1重构一切：Ctrl+Shift+Alt+T其他辅助 以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：Ø 命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。Ø 新建：Alt+Insert可以新建类、方法等任何东西。Ø 格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。Ø 切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。Ø 单元测试：Ctrl+Alt+T创建单元测试用例。Ø 运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。Ø 调试：F7/F8/F9分别对应Step into，Step over，Continue。此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴 很早以前拷贝过的，Alt+Shift+Insert(块选)进入到列模式进行按列选中 16.svn 不能同步代码问题修正12345678File -&gt; Settings -&gt;Subversion -&gt;General =&gt; Use command line client 选中使用command line方式需要指定svn.exe的路径,例如:D:\tools\TortoiseSVN\bin\svn.exe注意,安装TortoiseSVN时路径中不要带空格,例如:C:\Program Files\TortoiseSVN\bin\svn.exe就会报错.安装TortoiseSVN选择全部安装组件,否则可能没有svn.exe17.设置idea的SVN忽略掉*.iml文件Editor-&gt;File Types=&gt;Ignore files and folders增加*.iml;在lgnore files and folesrs中输入.idea;注意要&quot;;&quot;结尾。你就可以隐藏.idea文件夹了 18.改变编辑文本字体大小1File -&gt; settings -&gt; EDITOR COLORS &amp; FONTS -&gt; FONT -&gt; SIZE 19.IDEA编码设置1234FILE -&gt; SETTINGS -&gt; FILE ENCODINGS =&gt; IDE ENCODINGFILE -&gt; SETTINGS -&gt; FILE ENCODINGS =&gt; Project EncodingFILE -&gt; SETTINGS -&gt; FILE ENCODINGS =&gt; Default encoding for properties filesFILE -&gt; SETTINGS -&gt; FILE ENCODINGS =&gt; Transparent native-to-ascii conversion 20.Live Templates123456789System.out.println 快捷输出“abc”.sout =&gt; System.out.println(&quot;abc&quot;);在eclipse中使用方式为： sysout=&gt; System.out.println();for循环List&lt;String&gt; list = new ArrayList&lt;String&gt;();输入: list.for 即可输出for(String s:list)&#123;&#125; 21.配置tomcat参数1vm options: -Xms256m -Xmx512m -XX:PermSize=128m -XX:MaxPermSize=256m 22.idea安装插件的方法1234567891011以IntelliJ IDEA 14.0.1安装findbugs插件为例：(1)在线方式:进入File-&gt;setting-&gt;plugins-&gt;browse repositorits 搜索你要下载的插件名称，右侧可以找到下载地址,完成后按提示重启即可.(2)离线安装: 下载findbugs插件地址：http://plugins.jetbrains.com/plugin/3847,将下载的FindBugs-IDEA-0.9.994.zip,安装插件：进入File-&gt;setting-&gt;plugins=&gt; Install plugin from disk... 定位到到刚才下载的jar,点击ok,完成后按提示重启即可.插件安装的位置在C:\Users\xxxxxxxxx\.IntelliJIdea14\config\plugins\插件名下.安装iBATIS/MyBatis min-plugin插件 23.调整idea启动时的内存配置参数123%IDEA_HOME%/bin/idea.exe.vmoptions 24.导入eclipse web项目发布到Tomcat如果找不到导入eclipse web项目发布到Tomcat如果找不到,可以在环境配置的Facets增加web支持,在Artifacts中增加项目部署模块名 25.每次打开一个新jsp或java文件时,cpu都占用很高,去掉检验即可12每次打开一个新jsp或java文件时,cpu都占用很高,去掉检验即可:file-&gt;settings-&gt;editor-&gt;inspections 26.idea增加spring/struts关联文件支持1project Settings-&gt;Modules-&gt;选中项目右键可添加 28.IDEA开启类修改后自动编译1234File-&gt;setting-&gt;Buil,Execution,Deployment-&gt;compiler=&gt;Make project automatically编译错误问题解决Error:java: Compilation failed: internal java compiler errorset中Java complier 设置的问题 ，项目中有人用jdk1.6 有人用jdk1.7 版本不一样 会一起这个错误 28.提示实现Serializable接口1234使用 Eclipse 或 MyEclipse 的同学可能知道，如果 implements Serializable 接口时，会提示你生成 serialVersionUID。但 Intellij IDEA 默认没启用这个功能。Preferences-&gt;IEditor-&gt;nspections-&gt;Serialization issues-&gt;Serializable class without ’serialVersionUID’，选中以上后，在你的class中：光标定位在类名前，按 Alt+Enter 就会提示自动创建 serialVersionUID了 29.演出模式123456789我们可以使用【Presentation Mode】，将IDEA弄到最大，可以让你只关注一个类里面的代码，进行毫无干扰的coding。可以使用Alt+V快捷键，谈出View视图，然后选择Enter Presentation Mode。效果如下：这个模式的好处就是，可以让你更加专注，因为你只能看到特定某个类的代码。可能读者会问，进入这个模式后，我想看其他类的代码怎么办？这个时候，就要考验你快捷键的熟练程度了。你可以使用CTRL+E弹出最近使用的文件。又或者使用CTRL+N和CTRL+SHIFT+N定位文件。如何退出这个模式呢？很简单，使用ALT+V弹出view视图，然后选择Exit Presentation Mode 即可。但是我强烈建议你不要这么做，因为你是可以在Enter Presentation Mode模式下在IDEA里面做任何事情的。当然前提是，你对IDEA足够熟练。 30.神奇的Inject language123456789如果你使用IDEA在编写JSON字符串的时候，然后要一个一个\去转义双引号的话，就实在太不应该了，又烦又容易出错。在IDEA可以使用Inject language帮我们自动转义双引号。先将焦点定位到双引号里面，使用alt+enter快捷键弹出inject language视图，并选中Inject language or reference。选择后,切记，要直接按下enter回车键，才能弹出inject language列表。在列表中选择 json组件。选择完后。鼠标焦点自动会定位在双引号里面，这个时候你再次使用alt+enter就可以看到选中Edit JSON Fragment并回车，就可以看到编辑JSON文件的视图了。可以看到IDEA确实帮我们自动转义双引号了。如果要退出编辑JSON信息的视图，只需要使用ctrl+F4快捷键即可。Inject language可以支持的语言和操作多到你难以想象，读者可以自行研究。 31.idea快捷键和Windows默认快捷键冲突解决（如：Ctrl+Alt+↑或Ctrl+Alt+F12）1解决方式：在桌面右键 - 图形选项 - 快捷键 - 禁止 就可以了]]></content>
      <tags>
        <tag>idea</tag>
        <tag>技巧</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java程序员常用的22个Linux命令]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F15%2FJava%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B8%B8%E7%94%A8%E7%9A%8422%E4%B8%AALinux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[linux 命令查询网页 1. 查找文件1find / -name filename.txt 根据名称查找/目录下的filename.txt文件。 2. 查看一个程序是否运行1ps –ef|grep tomcat 查看所有有关tomcat的进程 3. 终止线程1kill -9 19979 终止线程号位19979的线程 4. 查看文件，包含隐藏文件1ls -al 5. 当前工作目录1pwd 6. 复制文件包括其子文件到自定目录1cp -r sourceFolder targetFolder 7. 创建目录1mkdir newfolder 8. 删除目录（此目录是空目录）1rmdir deleteEmptyFolder 9. 删除文件包括其子文件12rm -rf deleteFile## 注意deleteFile 不要用参数代替，容易岛主参数为空 然后炸了 10. 移动文件1mv /temp/movefile /targetFolder 扩展重命名 mv oldNameFile newNameFile 11. 切换用户1su -username 12. 修改文件权限12chmod 777 file.java//file.java的权限-rwxrwxrwx，r表示读、w表示写、x表示可执行 13. 压缩文件1tar -czf test.tar.gz /test1 /test2 14. 列出压缩文件列表1tar -tzf test.tar.gz 15. 解压文件1tar -xvzf test.tar.gz 16. 查看文件头10行1head -n 10 example.txt 17. 查看文件尾10行1tail -n 10 example.txt 18. 查看日志文件12tail -f exmaple.log//这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。 19. 启动Vi编辑器12vi## 打开某文件 vi xx.log 20. 查看系统当前时间1date 命令会输出 周几 几月 几日 时间 和 时间显示格式 和年份 Sat Jan 20 04:39:49 CST 2018 1date +&quot;%Y-%m-%d&quot; 显示如下： 1[root@ming xxx]# date +&quot;%Y-%m-%d&quot; 2018-01-20 注：这个我们如果不确定 就help 即可； 21. 解压zip 文件1unzip -oq 22. 查看线程个数（方便查看程序是否有误）1ps -Lf 端口号|wc -l]]></content>
      <tags>
        <tag>linux</tag>
        <tag>java</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F14%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[v2rayN 订阅地址https://sub.jiyou.cloud/modules/servers/V2raySocks/osubscribe.php?sid=31349&amp;token=V1s9qxIzPSfH 汝霖ssrssr://MTU1LjEzOC4yMjYuMTkzOjIzNTU6b3JpZ2luOmFlcy0yNTYtY2ZiOnBsYWluOmFtRnpiMjQ ssr 20190813ssr://MTM4LjE5Ny4yMzMuMTI1OjEzNjU3OmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWNmYjp0bHMxLjJfdGlja2V0X2F1dGg6TVRJek5EVTIvP29iZnNwYXJhbT1ZMnh2ZFdSbWNtOXVkQzV1WlhRJnByb3RvcGFyYW09JnJlbWFya3M9ZFhNeExVUlAmZ3JvdXA9YzJoaFpHOTNjMnQ1 ssr://NS4xODAuNzcuMTA0OjEzNjU3OmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWNmYjp0bHMxLjJfdGlja2V0X2F1dGg6TVRJek5EVTIvP29iZnNwYXJhbT1ZMnh2ZFdSbWNtOXVkQzV1WlhRJnByb3RvcGFyYW09JnJlbWFya3M9YW5BeExVUlcmZ3JvdXA9YzJoaFpHOTNjMnQ1 ssr://NDUuMTEuMi4xMzI6MTM2NTc6YXV0aF9hZXMxMjhfbWQ1OmFlcy0yNTYtY2ZiOnRsczEuMl90aWNrZXRfYXV0aDpNVEl6TkRVMi8_b2Jmc3BhcmFtPVkyeHZkV1JtY205dWRDNXVaWFEmcHJvdG9wYXJhbT0mcmVtYXJrcz1hbkF5TFVSVyZncm91cD1jMmhoWkc5M2MydDU ssr://NDUuODguNDEuOTQ6MTM2NTc6YXV0aF9hZXMxMjhfbWQ1OmFlcy0yNTYtY2ZiOnRsczEuMl90aWNrZXRfYXV0aDpNVEl6TkRVMi8_b2Jmc3BhcmFtPVkyeHZkV1JtY205dWRDNXVaWFEmcHJvdG9wYXJhbT0mcmVtYXJrcz1hbkEwTFVSVyZncm91cD1jMmhoWkc5M2MydDU ssr://MTg1LjI0My4xMTUuMTQ5OjEzNjU3OmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWNmYjp0bHMxLjJfdGlja2V0X2F1dGg6TVRJek5EVTIvP29iZnNwYXJhbT1ZMnh2ZFdSbWNtOXVkQzV1WlhRJnByb3RvcGFyYW09JnJlbWFya3M9WkdVeExVTlMmZ3JvdXA9YzJoaFpHOTNjMnQ1 ssr://MTAzLjEyNi4xMzcuMTA4OjEzNjU3OmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWNmYjp0bHMxLjJfdGlja2V0X2F1dGg6TVRJek5EVTIvP29iZnNwYXJhbT1ZMnh2ZFdSbWNtOXVkQzV1WlhRJnByb3RvcGFyYW09JnJlbWFya3M9WVhVeExWQlUmZ3JvdXA9YzJoaFpHOTNjMnQ1 ssr://NS4xODMuMTAyLjI1MToxMzY1NzphdXRoX2FlczEyOF9tZDU6YWVzLTI1Ni1jZmI6dGxzMS4yX3RpY2tldF9hdXRoOk1USXpORFUyLz9vYmZzcGFyYW09WTJ4dmRXUm1jbTl1ZEM1dVpYUSZwcm90b3BhcmFtPSZyZW1hcmtzPWRXc3hMVVJXJmdyb3VwPWMyaGhaRzkzYzJ0NQ ssr://NS4xODMuMTAwLjE0NjoxMzY1NzphdXRoX2FlczEyOF9tZDU6YWVzLTI1Ni1jZmI6dGxzMS4yX3RpY2tldF9hdXRoOk1USXpORFUyLz9vYmZzcGFyYW09WTJ4dmRXUm1jbTl1ZEM1dVpYUSZwcm90b3BhcmFtPSZyZW1hcmtzPWJtOHhMVVJXJmdyb3VwPWMyaGhaRzkzYzJ0NQ ssr://MTYxLjEyOS40MS4yMjoxMzY1NzphdXRoX2FlczEyOF9tZDU6YWVzLTI1Ni1jZmI6dGxzMS4yX3RpY2tldF9hdXRoOk1USXpORFUyLz9vYmZzcGFyYW09WTJ4dmRXUm1jbTl1ZEM1dVpYUSZwcm90b3BhcmFtPSZyZW1hcmtzPWRYTXlMVlZQJmdyb3VwPWMyaGhaRzkzYzJ0NQ ssr://NjguMTgzLjI0OS42MToxMzY1NzphdXRoX2FlczEyOF9tZDU6YWVzLTI1Ni1jZmI6dGxzMS4yX3RpY2tldF9hdXRoOk1USXpORFUyLz9vYmZzcGFyYW09WTJ4dmRXUm1jbTl1ZEM1dVpYUSZwcm90b3BhcmFtPSZyZW1hcmtzPWRYTTBMVVJQJmdyb3VwPWMyaGhaRzkzYzJ0NQ ssr://MTc4LjEyOC4xOTEuODM6MTM2NTc6YXV0aF9hZXMxMjhfbWQ1OmFlcy0yNTYtY2ZiOnRsczEuMl90aWNrZXRfYXV0aDpNVEl6TkRVMi8_b2Jmc3BhcmFtPVkyeHZkV1JtY205dWRDNXVaWFEmcHJvdG9wYXJhbT0mcmVtYXJrcz1kWE0xTFVSUCZncm91cD1jMmhoWkc5M2MydDU ssr://MTA0LjI0OC43OS45NjoxMzY1NzphdXRoX2FlczEyOF9tZDU6YWVzLTI1Ni1jZmI6dGxzMS4yX3RpY2tldF9hdXRoOk1USXpORFUyLz9vYmZzcGFyYW09WTJ4dmRXUm1jbTl1ZEM1dVpYUSZwcm90b3BhcmFtPSZyZW1hcmtzPWRYTTJMVVJQJmdyb3VwPWMyaGhaRzkzYzJ0NQ ssr://NDUuMTEuMy4xMTQ6MTM2NTc6YXV0aF9hZXMxMjhfbWQ1OmFlcy0yNTYtY2ZiOnRsczEuMl90aWNrZXRfYXV0aDpNVEl6TkRVMi8_b2Jmc3BhcmFtPVkyeHZkV1JtY205dWRDNXVaWFEmcHJvdG9wYXJhbT0mcmVtYXJrcz1kWE01TFVSVyZncm91cD1jMmhoWkc5M2MydDU ssr://MTAzLjk1LjIwNy4xODg6MTM2NTc6YXV0aF9hZXMxMjhfbWQ1OmFlcy0yNTYtY2ZiOnRsczEuMl90aWNrZXRfYXV0aDpNVEl6TkRVMi8_b2Jmc3BhcmFtPVkyeHZkV1JtY205dWRDNXVaWFEmcHJvdG9wYXJhbT0mcmVtYXJrcz1kWE14TUMxUlF3Jmdyb3VwPWMyaGhaRzkzYzJ0NQ ssr://MTYxLjEyOS40MS4zNjoxMzY1NzphdXRoX2FlczEyOF9tZDU6YWVzLTI1Ni1jZmI6dGxzMS4yX3RpY2tldF9hdXRoOk1USXpORFUyLz9vYmZzcGFyYW09WTJ4dmRXUm1jbTl1ZEM1dVpYUSZwcm90b3BhcmFtPSZyZW1hcmtzPWRYTXhNUzFWVHcmZ3JvdXA9YzJoaFpHOTNjMnQ1 ssr://MjMuMTUyLjAuMjIyOjEzNjU3OmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWNmYjp0bHMxLjJfdGlja2V0X2F1dGg6TVRJek5EVTIvP29iZnNwYXJhbT1ZMnh2ZFdSbWNtOXVkQzV1WlhRJnByb3RvcGFyYW09JnJlbWFya3M9ZFhNeE1pMURVZyZncm91cD1jMmhoWkc5M2MydDU ssr://MTcyLjg2LjcwLjE3OToxMzY1NzphdXRoX2FlczEyOF9tZDU6YWVzLTI1Ni1jZmI6dGxzMS4yX3RpY2tldF9hdXRoOk1USXpORFUyLz9vYmZzcGFyYW09WTJ4dmRXUm1jbTl1ZEM1dVpYUSZwcm90b3BhcmFtPSZyZW1hcmtzPWRYTXhNeTFJUmcmZ3JvdXA9YzJoaFpHOTNjMnQ1 ssr://MTcyLjI0Ny4xMjcuMjE2OjEzNjU3OmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWNmYjp0bHMxLjJfdGlja2V0X2F1dGg6TVRJek5EVTIvP29iZnNwYXJhbT1ZMnh2ZFdSbWNtOXVkQzV1WlhRJnByb3RvcGFyYW09JnJlbWFya3M9YUdzeExWZEwmZ3JvdXA9YzJoaFpHOTNjMnQ1 ssr://MTE2LjI1MS4yMjIuMTk4OjEzNjU3OmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWNmYjp0bHMxLjJfdGlja2V0X2F1dGg6TVRJek5EVTIvP29iZnNwYXJhbT1ZMnh2ZFdSbWNtOXVkQzV1WlhRJnByb3RvcGFyYW09JnJlbWFya3M9YzJjeUxVbFcmZ3JvdXA9YzJoaFpHOTNjMnQ1 ssr://OTIuMzguMTg5LjI4OjEzNjU3OmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWNmYjp0bHMxLjJfdGlja2V0X2F1dGg6TVRJek5EVTIvP29iZnNwYXJhbT1ZMnh2ZFdSbWNtOXVkQzV1WlhRJnByb3RvcGFyYW09JnJlbWFya3M9Y25VeExVZE0mZ3JvdXA9YzJoaFpHOTNjMnQ1 ssr://OTIuMzguMTI4LjIzNToxMzY1NzphdXRoX2FlczEyOF9tZDU6YWVzLTI1Ni1jZmI6dGxzMS4yX3RpY2tldF9hdXRoOk1USXpORFUyLz9vYmZzcGFyYW09WTJ4dmRXUm1jbTl1ZEM1dVpYUSZwcm90b3BhcmFtPSZyZW1hcmtzPWNuVXlMVWRNJmdyb3VwPWMyaGhaRzkzYzJ0NQ ssr://MzYuMjMyLjQwLjU2OjEzNjU3OmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWNmYjp0bHMxLjJfdGlja2V0X2F1dGg6TVRJek5EVTIvP29iZnNwYXJhbT1ZMnh2ZFdSbWNtOXVkQzV1WlhRJnByb3RvcGFyYW09JnJlbWFya3M9ZEhjeExVMVcmZ3JvdXA9YzJoaFpHOTNjMnQ1 ssr://MTAzLjE5Ni4yMi4yMTU6MTM2NTc6YXV0aF9hZXMxMjhfbWQ1OmFlcy0yNTYtY2ZiOnRsczEuMl90aWNrZXRfYXV0aDpNVEl6TkRVMi8_b2Jmc3BhcmFtPVkyeHZkV1JtY205dWRDNXVaWFEmcHJvdG9wYXJhbT0mcmVtYXJrcz1kSGN5TFUxVyZncm91cD1jMmhoWkc5M2MydDU ssr://NS4xODAuNzkuMTMzOjEzNjU3OmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWNmYjp0bHMxLjJfdGlja2V0X2F1dGg6TVRJek5EVTIvP29iZnNwYXJhbT1ZMnh2ZFdSbWNtOXVkQzV1WlhRJnByb3RvcGFyYW09JnJlbWFya3M9Ym13eExVUlcmZ3JvdXA9YzJoaFpHOTNjMnQ1 备用蓝灯https://ppt.cc/fJ6r8x 这个地址测试能够下载 PC https://github.com/lanternpro/about/blob/master/download.md github 下载 安卓 软件下载v2rayN https://1.2345345.xyz/ads.html]]></content>
      <tags>
        <tag>翻墙</tag>
        <tag>科学上网</tag>
        <tag>ssr</tag>
        <tag>v2rayN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring定时器quartz源码demo配置文件版]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F14%2Fspring%E5%AE%9A%E6%97%B6%E5%99%A8quartz%E6%BA%90%E7%A0%81demo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%89%88%2F</url>
    <content type="text"><![CDATA[基于spring quartz实现定时器功能，写死在配置文件中 准备使用的是quartz-2.2.2.jar,理论可以使用1.8以上的quartz quartz在线解析 左侧连接 教学了cron表达式基础 1234567常用表达式例子 （0）0/20 * * * * ? 表示每20秒 调整任务 （1）0 0 2 1 * ? 表示在每月的1日的凌晨2点调整任务 （2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业 （3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 （4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 （5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd"&gt; &lt;!-- 配置事务切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="serviceOperation" expression="execution(* com.cter.service..*.*(..))" /&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="serviceOperation" /&gt; &lt;/aop:config&gt; &lt;!-- 自动加载package下面指定的bean --&gt; &lt;context:component-scan base-package="com.cter"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;!-- 定义调用对象和调用对象的方法 --&gt; &lt;bean id="startWorkJobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;!-- 调用的类 --&gt; &lt;property name="targetObject" ref="startWorkJob" /&gt; &lt;!-- 调用类中的方法 --&gt; &lt;property name="targetMethod" value="startWork" /&gt; &lt;!-- 是否允许任务并发执行。当值为false时，表示必须等到前一个线程处理完毕后才再启一个新的线程 --&gt; &lt;property name="concurrent" value="false"/&gt; &lt;/bean&gt; &lt;!-- quartz-2.x的配置 --&gt; &lt;!-- 定义触发时间 --&gt; &lt;bean id="startWorkJobTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail"&gt; &lt;ref bean="startWorkJobDetail" /&gt; &lt;/property&gt; &lt;property name="cronExpression"&gt; &lt;value&gt;0/10 * * * * ?&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 总管理类 如果将lazy-init='false'那么容器启动就会执行调度程序 --&gt; &lt;!-- 如果lazy-init='true',则需要实例化该bean才能执行调度程序 --&gt; &lt;bean name="startQuertz" lazy-init="false" autowire="no" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;property name="triggers"&gt; &lt;list&gt;&lt;!-- &lt;ref bean="startWorkJobTrigger" /&gt; --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; StartWorkJob.java12345678910111213141516171819202122package com.cter.service;import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.stereotype.Component;/** * 测试定时器 * @author op1768 *///使用 @Component注入指定的bean名称@Component("startWorkJob")public class StartWorkJob &#123; //配置文件中的加载的方法，可以在方法中写需要的定时任务 public void startWork()&#123; Date date=new Date(); String dateStr=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(date); System.out.println(dateStr+"\t我是定时器。我启动了"); &#125;&#125; 动态加载 quartz 可以参考https://github.com/xkcoding/spring-boot-demo/tree/master/spring-boot-demo-task-quartz 是springboot-demo系列]]></content>
      <tags>
        <tag>spring</tag>
        <tag>quartz</tag>
        <tag>模版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习路线]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F13%2Fjava%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[诗和远方http://www.315310.top/c/ 群主发的 https://www.pornhub.com p站 掉头发]]></content>
      <tags>
        <tag>java学习</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat进程意外退出的问题分析]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F12%2FTomcat%E8%BF%9B%E7%A8%8B%E6%84%8F%E5%A4%96%E9%80%80%E5%87%BA%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[图片]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F08%2F%E5%A4%A7%E9%9B%84%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>大雄</tag>
        <tag>小舅子</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea快捷键映射表]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F07%2Fidea%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%98%A0%E5%B0%84%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[网页IDEADefaultKeymap.html 效果 其他文字版IDEA 快捷键 java开发手册华山版.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[idea全局护眼色绿豆沙]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F07%2Fidea%E5%85%A8%E5%B1%80%E6%8A%A4%E7%9C%BC%E8%89%B2%E7%BB%BF%E8%B1%86%E6%B2%99%2F</url>
    <content type="text"><![CDATA[原文https://blog.csdn.net/qq_37664102/article/details/81711046 1.在导航栏选择Help-&gt;FindAction或者shift+ctrl+A 2.输入 set background Image 3.选择背景图片，然后吧opactiy设置成100 就这样就设置成功了。 最后送上送上博主的图片下载连接 保护色.png 密码： je8a]]></content>
      <tags>
        <tag>ide</tag>
        <tag>护眼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中如何获取日期时间中的星期几？]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F06%2Fjava%E4%B8%AD%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E4%B8%AD%E7%9A%84%E6%98%9F%E6%9C%9F%E5%87%A0%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[###1、取得指定日期是星期几 取得指定日期是星期几可以采用下面两种方式取得日期是星期几： ##a、使用Calendar类 根据日期取得星期几 12345678910public static String getWeek(Date date)&#123; String[] weeks = &#123;"星期日","星期一","星期二","星期三","星期四","星期五","星期六"&#125;; Calendar cal = Calendar.getInstance(); cal.setTime(date); int week_index = cal.get(Calendar.DAY_OF_WEEK) - 1; if(week_index&lt;0)&#123; week_index = 0; &#125; return weeks[week_index];&#125; ##b、使用SimpleDateFormat类 1.根据日期取得星期几 12345public static String getWeek(Date date)&#123; SimpleDateFormat sdf = new SimpleDateFormat("EEEE");String week = sdf.format(date);return week;&#125; 注：格式化字符串存在区分大小写对于创建SimpleDateFormat传入的参数：EEEE代表星期，如“星期四”；MMMM代表中文月份，如“十一月”；MM代表月份，如“11”；yyyy代表年份，如“2010”；dd代表天，如“25” 2.取得日期是某年的第几周根据日期入得日期是某年的第几周。//取得日期是某年的第几周 123456public static int getWeekOfYear(Date date)&#123; Calendar cal = Calendar.getInstance(); cal.setTime(date); int week_of_year = cal.get(Calendar.WEEK_OF_YEAR); return week_of_year;&#125; 3、得到某年的某个月有多少天已知年份和月份，取得该月有多少天。//取得某个月有多少天 1234567public static int getDaysOfMonth(int year,int month)&#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, year); cal.set(Calendar.MONTH, month-1); int days_of_month = cal.getActualMaximum(Calendar.DAY_OF_MONTH); return days_of_month;&#125; b、使用SimpleDateFormat类4.已知两个日期，计算它们之间相差多少天。// 取得两个日期之间的相差多少天 12345public static long getDaysBetween(Date date0, Date date1) &#123;long daysBetween = (date0.getTime() - date1.getTime() + 1000000) / 86400000;// 86400000=3600241000 用立即数，减少乘法计算的开销return daysBetween;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>工具类</tag>
        <tag>获取日期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加速国内Github访问]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F06%2F%E5%8A%A0%E9%80%9F%E5%9B%BD%E5%86%85Github%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[由于某些原因，国内访问Github会异常缓慢，在clone仓库时甚至只有10k以下的速度，下载半天有时还会失败需要从头再来，甚是让人恼火。 本文介绍通过修改系统hosts文件的办法，绕过国内dns解析，直接访问GitHub的CDN节点，从而达到加速的目的。不需要科学上网，也不需要海外的服务器辅助。 指向于github常用的站点进行解析直接访问对应的ip 这样就节省了解析时间，加快访问速度。 ###1.常用github站点 123192.30.253.112 github.com151.101.72.133 assets-cdn.github.com151.101.193.194 github.global.ssl.fastly.net 2.修改系统hosts文件，直接访问打开系统hosts文件(需管理员权限)。路径：C:\Windows\System32\drivers\etc 在末尾添加上面的三行记录并保存。(需管理员权限，注意IP地址与域名间需留有空格) 示例： 12345# 127.0.0.1 localhost# ::1 localhost192.30.253.112 github.com151.101.72.133 assets-cdn.github.com151.101.193.194 github.global.ssl.fastly.net ###3.刷新系统DNS缓存 Windows+X 打开系统命令行（管理员身份）或powershell 运行 ipconfig /flushdns 手动刷新系统DNS缓存。 1ipconfig /flushdns ok 访问https://github.com/ 快了一点点]]></content>
      <tags>
        <tag>github dns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决在Markdown中的表格单元格合并的问题]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F05%2F%E8%A7%A3%E5%86%B3%E5%9C%A8Markdown%E4%B8%AD%E7%9A%84%E8%A1%A8%E6%A0%BC%E5%8D%95%E5%85%83%E6%A0%BC%E5%90%88%E5%B9%B6%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[markdown 默认是不支持单元格合并的必须使用html 嵌套进入markdown里面 然后修改对应的html进行合并 引入HTML时需要注意的需要注意的一点是，在markdown中使用html代码来实现表格的效果，需要在表格的外面套上 12345&lt;escape&gt; //html 代码&lt;/escape&gt;colspan=&quot;2&quot; rowspan=&quot;2&quot; 示例 12345678910111213141516171819202122&lt;escape&gt;&lt;table&gt; &lt;tr&gt; &lt;th&gt;项目1&lt;/th&gt; &lt;th&gt;项目2&lt;/th&gt; &lt;th&gt;项目3&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;a1&lt;/td&gt; &lt;td colspan=&quot;2&quot; &gt;&lt;font color=&quot;Hotpink&quot;&gt;colspan=&quot;2&quot;&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; &gt;&lt;font color=&quot;Hotpink&quot;&gt;colspan=&quot;2&quot;&lt;/font&gt; &lt;/td&gt; &lt;td&gt;b2&lt;/td&gt; &lt;td&gt;b3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;c2&lt;/td&gt; &lt;td&gt;c3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/escape&gt; ##效果图## 项目1 项目2 项目3 a1 colspan="2" colspan="2" b3 rowspan="2" c2 c3 c2 c3 如何偷懒http://www.tablesgenerator.com/ 可以直接copy excel 表格内容到 然后进行修改内容]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚本启动tomcat]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F02%2F%E8%84%9A%E6%9C%AC%E5%90%AF%E5%8A%A8tomcat%2F</url>
    <content type="text"><![CDATA[1234#!/bin/bashsh /usr/local/tomcat/ov_8081/bin/shutdown.shsh /usr/local/tomcat/ov_8081/bin/startup.shtail -f /usr/local/tomcat/ov_8081/logs/catalina.out]]></content>
      <tags>
        <tag>脚本</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaB站]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F02%2FjavaB%E7%AB%99%2F</url>
    <content type="text"><![CDATA[https://www.bilibili.com/video/av36806419 基础，上面的是视频的番号https://www.bilibili.com/video/av47176832 Java 编程学习第一季》： av47103781https://www.bilibili.com/video/av47176832Java 企业开发第一季 - Spring 实战》： av47176832https://www.bilibili.com/video/av47228830《Java 企业开发第二季 - MyBatis 实战》： av47228830https://www.bilibili.com/video/av47218566《Java 企业开发第三季 - Spring MVC 实战》： av47218566https://www.bilibili.com/video/av47230137《Java 企业开发第四季 - Spring Boot 实战》： av47230137https://www.bilibili.com/video/ 《Java 企业开发第五季 - Spring Cloud 实战》：https://www.bilibili.com/video/av47009143 Java 企业开发第六季 - Dubbo 实战》： av47009143https://www.bilibili.com/video/av48308453 《Java 企业开发第七季 - 电商项目实战》： av48308453 https://www.bilibili.com/video/av47702905《数据库第一季 - MySQL 实战》： av47702905https://www.bilibili.com/video/av47423174 《数据库第二季 - Redis 实战》： av47423174https://www.bilibili.com/video/av47425352 《数据库第三季 - MongoDB 实战》： av47425352https://www.bilibili.com/video/av48279989 《数据库第四季 - Elasticsearch 实战》： av48279989https://www.bilibili.com/video/av48502473《数据库第五季 - Oracle 实战》： av48502473https://www.bilibili.com/video/av49126649 《前端开发第一季 - HTML + CSS 实战》： av49126649https://www.bilibili.com/video/av48927313 《前端开发第二季 - Javascript 实战》： av48927313https://www.bilibili.com/video/av48033695 《前端开发第三季 - React 实战》： av48033695https://www.bilibili.com/video/av50886891 《前端开发第四季 - Vue 实战》： av50886891https://www.bilibili.com/video/av48495066 《前端开发第五季 - React 项目实战》： av48495066https://www.bilibili.com/video/av48333477 《前端开发第六季 - Vue 项目实战》： av48333477 https://www.bilibili.com/video/av47382482 《构建工具 Maven 视频教程全集（35P）》https://www.bilibili.com/video/av47701443 《版本控制 Git 视频教程全集（62P）》https://www.bilibili.com/video/av47702283 《操作系统 Linux 视频教程全集》https://www.bilibili.com/video/av48621769 《大数据开发第一季 - Hadoop》： av48621769https://www.bilibili.com/video/av48581792 《大数据开发第二季 - HBase》： av48581792https://www.bilibili.com/video/av48609427 《大数据开发第三季 - Hive》： av48609427https://www.bilibili.com/video/av50996367 《大数据开发第四季 - Flink》： av50996367https://www.bilibili.com/video/av48668079《大数据开发第五季 - Spark》： av48668079 https://www.bilibili.com/video/av48444262《架构之路第一季 - RabbitMQ》： av48444262https://www.bilibili.com/video/av47773990《架构之路第二季 - Kafka》： av47773990https://www.bilibili.com/video/av47773419《架构之路第三季 - Zookeeper》： av47773419 01、Java av4710378102、Spring av4717683203、Spring Mvc av4721856604、MyBatis av4722883005、Hibernate av4730428806、Spring Boot av4723013707、Spring Cloud08、Dubbo av4700914309、MySQL av4770290510、Redis av4742317411、MongoDB av4742535212、Elasticsearch av4827998913、Zookeeper av4777341914、Kafka av4777399015、Linux av4770228316、Docker av4771528217、Maven av4738248218、Git av4770144319、Jenkins av4771470620、IDEA av4771516121、Shiro av4771553622、React av4803369523、Vue av4833347724、电商项目实战 av4830845325、RBAC 权限系统 av4830571926、数据结构与算法 av4850555627、Oracle av4850247328、ActiveMQ av4856247429、TCP/IP av4856242630、HTTP av4856145531、Netty av4857020232、Gradle av4858111933、HBase av4858179234、Kubernetes av4858245635、Hive av4860942736、Hadoop av4862176937、Spark av48668079]]></content>
      <tags>
        <tag>java资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本语言]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F02%2Fshell%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[从事机顶盒开发以来，看到很多的Shell脚本，比如：开机启动脚本、系统升级脚本、软探针脚本、和系统编译脚本。这些脚本都是用shell语言开发，虽然在平时的需求开发和维护中会涉及到一定的脚本修改，但是一直没有系统的学习过shell语言。所以本篇文章主要是记录学习shell过程中的笔记。同时也为巩固markdown语法，本篇笔记都是用markdown记录。 shell脚本语言1、什么是shell脚本语言？脚本语言是像剧本一样教计算机办某个事情的语言。 脚本语言其实就是短小的、用来让计算机自动化完成一系列工作的程序，这类程序可以用文本编辑器修改 不需要编译，通常解释运行。 2、运行shell脚本的两个方法12chmod +x ./XXX.sh chmod后有空格./XXX.sh 1/bin/sh XXX.sh 3、shell变量定义变量时，变量名不加$，如： 1your_name=&quot;runoob.com&quot; 使用定义过的变量时，只要在变量名前面加上$符号即可，如： 12your_name=&quot;qinjx&quot;echo $&#123;your_name&#125; 只读变量12readonly myUrlmyUrl=&quot;www.baidu.com&quot; 删除变量1unset myUrl 变量类型1、局部变量 ：局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动程序不能访问变量 2、环境变量 ：所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量 3、shell变量 ：shell变量是由shell程序设置的特殊变量，shell变量中有一部风是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 4、shell字符串字符串可以使用单引号也可以使用双引号，也可以不使用引号 强烈建议使用双引号 获取字符串长度12string=&quot;adcg&quot;echo $&#123;#string&#125; 多了个# 提取字符串12string=&quot;runoob is a great site&quot;scho $&#123;string 1:4&#125; 输出uoo ，从0开始算 5、shell数组shell只支持一维数组 定义数组用括号来表示数组，数组元素用“空格”符号分割开来，定义数组的一般形式为： 1array_name=(value0 value1 value2 value3) 读取数组1valuen=$&#123;array_name[1]&#125; 使用@符号可以获取数组中的所有元素，例如： 1echo $&#123;array_name[@]&#125; 取得数组元素的个数 1length=$&#123;#array_name[@] 取得数组单个元素的长度 1length=$&#123;#array_name[1]&#125; 6、shell传递参数脚本内获取参数的格式为：0代表文件名，、$1代表参数1，$2代表参数2。 输出不存在的参数时结果为空 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有脚本传递的参数 $$ 脚本运行的当前进程号 ​ 7、shell基本运算符无法把基本运算符结果false或者true当做字符串赋值给变量 进行四则运算时=两边不用空格，+两边一定要空格，四则运算一定要用双括号，比如 1num=(($num+1)) 算数运算符格式：expr a + b 表达式和运算符之间要有空格，例如2+2是不对的，必须写成2 + 2 完整的表达式要被``包含，注意这个字符不是常用的单引号 ​ 关系运算符关系运算符只支持数字，不支持字符串，除非字符串的值是数字 假定a=10，b=20 运算符 说明 举例 -eq 检测两个数是否相等，相等返回true [$a -eq $b] 返回false -ne 检测两个数是否相等，不相等返回true [$a -ne $b]返回true -gt 检测左边的数是否大于右边，如果是，返回true [$a -gt $b]返回false -lt 检测左边的数是否小于右边，如果是，返回true [$a -gt $b]返回true -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ b ] 返回 true。 布尔运算符 ！ 非运算 -0或运算 -a与运算 逻辑运算符&amp;&amp;与运算 ||或运算 字符串运算符 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n $a ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 文件测试运算符 运算符 说明 举例 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 8、shell流程控制if语句if语句 12345if ····then ····· ·····fi if else语句 1234567if ····then ···· ····else ····fi if else-if else 123456789if ·····then ······elif ····· then ·····else ·····fi for循环for循环格式为： 1234567for var in items items2 item3 .... itemsNdo command1 command2 ·· commandNdone while语句while循环用于不断执行一系列命令，也用于从输入文件中读取数据，命令通常为测试条件，其格式为： 1234while conditiondo commanddone 如果while condition涉及四则运算，需要使用双括号 单引号(‘’)：括起来的字符作为普通字符 双引号(“”):括起来的字符，除 “$”, “\”, “`”和“``”保留其特殊功能外，其余仍作为普通字符 反引号（``）:括起来的字串被解释为命令，shell首先执行该命令，并一他的标准输出结果例 9、shell函数无参函数shell中函数的定义格式如下： 12345[ function ] funname [()]&#123; action; [return int;]&#125; 可以带function fun()定义，也可以直接fun()定义，不带任何参数 参数返回，可以显示加，return返回，如果不加，将以最后一条命令运行结果，作为返回值。 1234567#!/bin/bashdemoFun()&#123; echo &quot;这是我的第一个 shell 函数!&quot;&#125;echo &quot;-----函数开始执行-----&quot;demoFunecho &quot;-----函数执行完毕-----&quot; 123456789101112#!/bin/bashfunWithReturn()&#123; echo &quot;这个函数会对输入的两个数字进行相加运算...&quot; echo &quot;输入第一个数字: &quot; read aNum echo &quot;输入第二个数字: &quot; read anotherNum echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot; return $(($aNum+$anotherNum))&#125;funWithReturnecho &quot;输入的两个数字之和为 $? !&quot; 函数返回值在调用后通过$?来获取 所有函数在使用前必须定义，这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用，调用函数仅使用其函数名即可 有参函数在shell中，调用函数时可以向其传递参数，，在函数内部，通过1表示第一个参数 1234567891011#!/bin/bashfunWithParam()&#123; echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 $&#123;10&#125; !&quot; echo &quot;第十一个参数为 $&#123;11&#125; !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 注意，{10} 参数处理 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 10、shell文件包含和其他语言一样，shell也可以包含外部脚本，这样可以很方便的封装一些公用的代码作为一个独立文件 语法如下： 12345. filename # 注意点号(.)和文件名中间有一空格或source filename 举例： test1.sh 12#!/bin/bashurl=&quot;http://www.runoob.com&quot; test2.sh 123456#!/bin/bash#使用 . 号来引用test1.sh 文件. ./test1.sh# 或者使用以下包含文件代码# source ./test1.shecho &quot;菜鸟教程官网地址：$url&quot; 结果为： 12$ chmod +x test2.sh $ ./test2.sh 被包含的文件test1.sh不需要可执行权限]]></content>
      <tags>
        <tag>脚本</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教你一招下载近乎全网视频]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F01%2F%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[教你一招下载近乎全网视频 https://bestzuo.cn/posts/5a881936.html 鸠摩搜索 https://www.jiumodiary.com/]]></content>
      <tags>
        <tag>下载，视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库面试题]]></title>
    <url>%2Fmyzou%2F2019%2F08%2F01%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[作者：追寻自我 转载 https://www.cnblogs.com/wenxiaofei/p/9853682.html 一、基本概念 ## 1.主键、外键、超键、候选键 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键：是最小超键，即没有冗余元素的超键。 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 外键：在一个表中存在的另一个表的主键称此表的外键。 2.为什么用自增列作为主键 如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、 如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、 如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。 数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点） 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。 3.触发器的作用？ 触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。 4.什么是存储过程？用什么来调用？存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 调用： 1）可以用一个命令对象来调用存储过程。 2）可以供外部程序调用，比如：java程序。 5.存储过程的优缺点？ 优点： 1）存储过程是预编译过的，执行效率高。 2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。 3）安全性高，执行存储过程需要有一定权限的用户。 4）存储过程可以重复使用，可减少数据库开发人员的工作量。 缺点：移植性差 6.存储过程与函数的区别 7.什么叫视图？游标是什么？ 视图： 是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。 游标： 是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。 8.视图的优缺点 优点： 1对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。 2)用户通过简单的查询可以从复杂查询中得到结果。 3)维护数据的独立性，试图可从多个表检索数据。 4)对于相同的数据可产生不同的视图。 缺点： 性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据 9.drop、truncate、 delete区别 最基本： drop直接删掉表。 truncate删除表中数据，再插入时自增长id又从1开始。 delete删除表中数据，可以加where字句。 （1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。 （2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。 （3） 一般而言，drop &gt; truncate &gt; delete （4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view （5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。 （6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。 （7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。 （8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。 （9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。 （10） Truncate table 表名 速度快,而且效率高,因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 （11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。 （12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。 10.什么是临时表，临时表什么时候删除? 临时表可以手动删除：DROP TEMPORARY TABLE IF EXISTS temp_tb; 临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY， 如： CREATE TEMPORARY TABLE tmp_table ( NAME VARCHAR (10) NOT NULL, time date NOT NULL); select * from tmp_table; 11.非关系型数据库和关系型数据库区别，优势比较? 非关系型数据库的优势： 性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 关系型数据库的优势： 复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持：使得对于安全性能很高的数据访问要求得以实现。 其他： 1.对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 2.NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。 3.对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。 12.数据库范式，根据某个场景设计数据表? 第一范式:(确保每列保持原子性)所有字段值都是不可分解的原子值。 第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。 第二范式:(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。 第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。 第三范式:(确保每列都和主键列直接相关,而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。 BCNF:符合3NF，并且，主属性不依赖于主属性。 若关系模式属于第二范式，且每个属性都不传递依赖于键码，则R属于BC范式。通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。一般，一个数据库设计符合3NF或BCNF就可以了。 第四范式:要求把同一表内的多对多关系删除。 第五范式:从最终结构重新建立原始结构。 13.什么是 内连接、外连接、交叉连接、笛卡尔积等? 内连接: 只连接匹配的行 左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行 右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行 例如1：SELECT a.,b. FROM luntan LEFT JOIN usertable as b ON a.username=b.username 例如2：SELECT a.,b. FROM city as a FULL OUTER JOIN user as b ON a.username=b.username 全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。 交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配 例如：SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type 注意： 很多公司都只是考察是否知道其概念，但是也有很多公司需要不仅仅知道概念，还需要动手写sql,一般都是简单的连接查询，具体关于连接查询的sql练习，参见以下链接： 牛客网数据库SQL实战 leetcode中文网站数据库练习 我的另一篇文章，常用sql练习50题 14.varchar和char的使用场景? 1.char的长度是不可变的，而varchar的长度是可变的。 定义一个char[10]和varchar[10]。如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。 2.char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。varchar是以空间效率为首位。 3.char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。 4.两者的存储数据都非unicode的字符数据。 15.SQL语言分类 SQL语言共分为四大类： 数据查询语言DQL 数据操纵语言DML 数据定义语言DDL 数据控制语言DCL。 1. 数据查询语言DQL 数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块： SELECTFROMWHERE 2 .数据操纵语言DML 数据操纵语言DML主要有三种形式： 1) 插入：INSERT 2) 更新：UPDATE 3) 删除：DELETE 3. 数据定义语言DDL 数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如：CREATE TABLE/VIEW/INDEX/SYN/CLUSTER 表 视图 索引 同义词 簇 DDL操作是隐性提交的！不能rollback 4. 数据控制语言DCL 数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如： 1) GRANT：授权。 2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚—ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为：SQL&gt;ROLLBACK; 3) COMMIT [WORK]：提交。 在数据库的插入、删除和修改操作时，只有当事务在提交到数据库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看到所做的事情，别人只有在最后提交完成后才可以看到。提交数据有三种类型：显式提交、隐式提交及自动提交。下面分别说明这三种类型。 (1) 显式提交用COMMIT命令直接完成的提交为显式提交。其格式为：SQL&gt;COMMIT； (2) 隐式提交用SQL命令间接完成的提交为隐式提交。这些命令是：ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。 (3) 自动提交若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，系统将自动进行提交，这就是自动提交。其格式为：SQL&gt;SET AUTOCOMMIT ON； 参考文章：https://www.cnblogs.com/study-s/p/5287529.html 16.like %和-的区别 通配符的分类: %百分号通配符:表示任何字符出现任意次数(可以是0次). _下划线通配符:表示只能匹配单个字符,不能多也不能少,就是一个字符. like操作符: LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较. 注意: 如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的,SELECT * FROM products WHERE products.prod_name like ‘1000’;只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果. %通配符使用: 匹配以”yves”开头的记录:(包括记录”yves”) SELECT FROM products WHERE products.prod_name like ‘yves%’;匹配包含”yves”的记录(包括记录”yves”) SELECT FROM products WHERE products.prod_name like ‘%yves%’;匹配以”yves”结尾的记录(包括记录”yves”,不包括记录”yves “,也就是yves后面有空格的记录,这里需要注意) SELECT * FROM products WHERE products.prod_name like ‘%yves’; 通配符使用: SELECT FROM products WHERE products.prod_name like ‘_yves’; 匹配结果为: 像”yyves”这样记录.SELECT FROM products WHERE products.prod\name like ‘yves**’; 匹配结果为: 像”yvesHe”这样的记录.(一个下划线只能匹配一个字符,不能多也不能少) 注意事项: 注意大小写,在使用模糊匹配时,也就是匹配文本时,mysql是可能区分大小的,也可能是不区分大小写的,这个结果是取决于用户对MySQL的配置方式.如果是区分大小写,那么像YvesHe这样记录是不能被”yves__”这样的匹配条件匹配的. 注意尾部空格,”%yves”是不能匹配”heyves “这样的记录的. 注意NULL,%通配符可以匹配任意字符,但是不能匹配NULL,也就是说SELECT * FROM products WHERE products.prod_name like ‘%;是匹配不到products.prod_name为NULL的的记录. 技巧与建议: 正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。 不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数. 参考博文：https://blog.csdn.net/u011479200/article/details/78513632 17.count(*)、count(1)、count(column)的区别 count(*)对行的数目进行计算,包含NULL count(column)对特定的列的值具有的行数进行计算,不包含NULL值。 count()还有一种使用方式,count(1)这个用法和count(*)的结果是一样的。 性能问题: 1.任何情况下SELECT COUNT(*) FROM tablename是最优选择; 2.尽量减少SELECT COUNT(*) FROM tablename WHERE COL = ‘value’ 这种查询; 3.杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 = ‘value’ 的出现。 如果表没有主键,那么count(1)比count(*)快。 如果有主键,那么count(主键,联合主键)比count(*)快。 如果表只有一个字段,count(*)最快。 count(1)跟count(主键)一样,只扫描主键。count(*)跟count(非主键)一样,扫描整个表。明显前者更快一些。 18.最左前缀原则 多列索引： ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age); 为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。 注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。 最左前缀原则：顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。 二、索引 ## 1.什么是索引？ 何为索引： 数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。 2.索引的作用？它的优点缺点是什么？ 索引作用： 协助快速查询、更新数据库表中数据。 为表设置索引要付出代价的： 一是增加了数据库的存储空间 二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。 3.索引的优缺点？ 创建索引可以大大提高系统的性能（优点）： 1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。 3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。 5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 增加索引也有许多不利的方面(缺点)： 1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 4.哪些列适合建立索引、哪些不适合建索引？ 索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。 一般来说，应该在这些列上创建索引： （1）在经常需要搜索的列上，可以加快搜索的速度； （2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构； （3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度； （4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； （5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； （6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 对于有些列不应该创建索引： （1）对于那些在查询中很少使用或者参考的列不应该创建索引。 这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 （2）对于那些只有很少数据值的列也不应该增加索引。 这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。 （3）对于那些定义为text, image和bit数据类型的列不应该增加索引。 这是因为，这些列的数据量要么相当大，要么取值很少。 (4)当修改性能远远大于检索性能时，不应该创建索引。 这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 5.什么样的字段适合建索引 唯一、不为空、经常被查询的字段 6.MySQL B+Tree索引和Hash索引的区别?Hash索引和B+树索引的特点： Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位; B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问; 为什么不都用Hash索引而使用B+树索引？ Hash索引仅仅能满足”=”,”IN”和””查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样； Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样； Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用； Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据； Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。 补充： 1.MySQL中，只有HEAP/MEMORY引擎才显示支持Hash索引。 2.常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。B+树索引和哈希索引的明显区别是： 3.如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据； 4.如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；同理，哈希索引没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）； 5.哈希索引也不支持多列联合索引的最左匹配规则； 6.B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。 7.在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。 7.B树和B+树的区别 B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息 B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息) 8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？ 1.B+的磁盘读写代价更低 B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 2.B+tree的查询效率更加稳定 由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。 9.聚集索引和非聚集索引区别? 聚合索引(clustered index): 聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。 非聚合索引(nonclustered index): 非聚集索引指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。 根本区别： 聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。 三、事务 ## 1.什么是事务？ 事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。 2.事务四大特性（ACID）原子性、一致性、隔离性、持久性? 原子性（Atomicity）:原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 一致性（Consistency）:事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。 隔离性（Isolation）:隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。 持久性（Durability）:持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别? 从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。事务的并发问题 1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据 2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。 3、幻读：幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。 例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。 事务的隔离级别 读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。 可重复读：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象 串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样 特别注意： MySQL默认的事务隔离级别为repeatable-read MySQL 支持 4 中事务隔离级别. 事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持. Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异 MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行 事务隔离级别：未提交读时，写数据只会锁住相应的行。 事务隔离级别为：可重复读时，写数据会锁住整张表。 事务隔离级别为：串行化时，读写数据都会锁住整张表。 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。 4.事务传播行为 1.PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。 2.PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。 3.PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。 4.PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。 5.PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 6.PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 7.PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 5.嵌套事务 什么是嵌套事务？ 嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了： 如果子事务回滚，会发生什么？ 父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。 如果父事务回滚，会发生什么？ 父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么： 事务的提交，是什么情况？ 是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。 参考文章：https://blog.csdn.net/liangxw1/article/details/51197560 四、存储引擎1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别? 两种存储引擎的大致区别表现在： 1.InnoDB支持事务，MyISAM不支持， 这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。 2.MyISAM适合查询以及插入为主的应用。 3.InnoDB适合频繁修改以及涉及到安全性较高的应用。 4.InnoDB支持外键，MyISAM不支持。 5.从MySQL5.5.5以后，InnoDB是默认引擎。 6.InnoDB不支持FULLTEXT类型的索引。 7.InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表。 8.对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。 9.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢。MyISAM则会重建表。 10.InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like ‘%lee%’。 2.MySQL存储引擎MyISAM与InnoDB如何选择 MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。 虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。关于MySQL数据库提供的两种存储引擎，MyISAM与InnoDB选择使用： 1.INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持。 2.MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。 如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。 如果你的应用程序对查询性能要求较高，就要使用MyISAM了。MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。 有人说MyISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。 现在一般都是选用innodb了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。MEMORY存储引擎 MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。 MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。 注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。 3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景? 事务处理上方面 MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。 InnoDB：提供事务支持事务，外部键等高级数据库功能。具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。 锁级别 MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。 InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。 关于存储引擎MyISAM和InnoDB的其他参考资料如下： MySQL存储引擎中的MyISAM和InnoDB区别详解 MySQL存储引擎之MyISAM和Innodb总结性梳理 五、优化 ## 1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序? 1.查询中用到的关键词主要包含六个，并且他们的顺序依次为 select–from–where–group by–having–order by 其中select和from是必须的，其他关键词是可选的，这六个关键词的执行顺序 与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行 from:需要从哪个数据表检索数据 where:过滤表中数据的条件 group by:如何将上面过滤出的数据分组 having:对上面已经分组的数据进行过滤的条件 select:查看结果集中的哪个列，或列的计算结果 order by :按照什么样的顺序来查看返回的数据 2.from后面的表关联，是自右向左解析 而where条件的解析顺序是自下而上的。 也就是说，在写SQL语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边 （用小表去匹配大表） 其他参考资源：http://www.cnblogs.com/huminxxl/p/3149097.html 2.使用explain优化sql和索引? 对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化 table：显示这一行的数据是关于哪张表的 type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL all:full table scan ;MySQL将遍历全表以找到匹配的行； index: index scan; index 和 all的区别在于index类型只遍历索引； range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询； ref：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找； eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描； const，system：当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。 possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句 key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引 key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好 ref：显示索引的哪一列被使用了，如果可能的话，是一个常数 rows：MySQL认为必须检查的用来返回请求数据的行数 Extra：关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。 3.MySQL慢查询怎么解决? slow_query_log 慢查询开启状态。 slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。 long_query_time 查询超过多少秒才记录。 六、数据库锁 ## 1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决? MySQL有三种锁的级别：页级、表级、行级。 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般什么情况下会造成死锁? 什么是死锁？ 死锁: 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。 表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。 死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。 那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。 死锁的解决办法? 1.查出的线程杀死 killSELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX; 2.设置锁的超时时间Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。 生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。 3.指定获取锁的顺序 2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁? 悲观锁（Pessimistic Lock）: 悲观锁特点:先获取锁，再进行业务操作。 即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。 补充：不同的数据库对select for update的实现和支持都是有所区别的， oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。 MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。 乐观锁（Optimistic Lock）: 1.乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。 2.**乐观锁的特点先进行业务操作，不到万不得已不去拿锁。**即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。 3.一般的做法是在需要锁的数据上增加一个版本号，或者时间戳， 实现方式举例如下： 乐观锁（给表加一个版本号字段） 这个并不是乐观锁的定义，给表加版本号，是数据库实现乐观锁的一种方式。 SELECT data AS old_data, version AS old_version FROM …; 根据获取的数据进行业务操作，得到new_data和new_version UPDATE SET data = new_data, version = new_version WHERE version = old_version if (updated row &gt; 0) { // 乐观锁获取成功，操作完成 } else { // 乐观锁获取失败，回滚并重试 } 注意： 乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能 乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。 总结：悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select … for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。 响应速度： 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。’ 冲突频率： 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。 重试代价： 如果重试代价大，建议采用悲观锁。 七、其他 ## 1.数据库的主从复制 主从复制的几种方式: 同步复制: 所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。 异步复制: 如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。 半同步复制: master只保证slaves中的一个操作成功，就返回，其他slave不管。这个功能，是由google为MySQL引入的。 2.数据库主从复制分析的 7 个问题?问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？ 假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。 问题2：主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？ 实现数据备份:类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。 异地容灾:比如master在北京，地震挂了，那么在上海的slave还可以继续。主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。【很可能的情况是，一个系统的读操作远远多于写操作，因此写操作发向master，读操作发向slaves进行操作】 问题3：主从复制中有master,slave1,slave2,…等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库? 我们在应用程序中可以这样，insert/delete/update这些更新数据库的操作，用connection(for master)进行操作， select用connection(for slaves)进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如使用简单的轮循算法。 这样的话，相当于应用程序完成了SQL语句的路由，而且与MySQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MySQL的主从复制架构没有什么太多关系呢？找一个组件，application program只需要与它打交道，用它来完成MySQL的代理，实现SQL语句的路由。MySQL proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。 这就是所谓的MySQL READ WRITE SPLITE，MySQL的读写分离。 问题4：如果MySQL proxy , direct , master他们中的某些挂了怎么办？ 总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。 问题5：当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2,slave-3,…它们怎么办？ 显 然，应该发N次。实际上，在MySQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,…的主，同时slave-1不再负责select。slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。 问题6：当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。 应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,…这些查询的结果都缓存至mamcache中。 问题7：随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？ scale on ?更好的服务器？没有最好的，只有更好的，太贵了。。。scale out ? 主从复制架构已经满足不了。可以分库【垂直拆分】，分表【水平拆分】。 3.mysql 高并发环境解决方案? MySQL 高并发环境解决方案： 分库 分表 分布式 增加二级缓存。。。。。 需求分析：互联网单位 每天大量数据读取，写入，并发性高。 现有解决方式：水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。 集群方案：解决DB宕机带来的单点DB不能访问问题。 读写分离策略：极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。 4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?转载：MySQL REDO日志和UNDO日志 Undo Log: Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了Undo Log来实现多版本并发控制(简称：MVCC)。 事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。 之所以能同时保证原子性和持久化，是因为以下特点： 更新数据前记录Undo log。为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。 缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。 Redo Log: 原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fmyzou%2F2019%2F07%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing https://hexo.io/docs/writing.html Run server1$ hexo server More info: Server https://hexo.io/docs/server.html Generate static files1$ hexo generate More info: Generating https://hexo.io/docs/generating.html Deploy to remote sites1$ hexo deploy More info: Deployment https://hexo.io/docs/deployment.html]]></content>
  </entry>
</search>
